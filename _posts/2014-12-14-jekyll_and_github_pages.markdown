---
layout: post
title:  "Blogging with Jekyll and GitHub pages"
date:   2014-12-14 13:54:00
categories: jekyll github
---

This post describes my setup for blogging. It is based on [Jekyll] for generating the content, and [GitHub pages] for serving. There are plenty of extra frameworks to achieve the same result. However, for me, those frameworks add to much layer of complexity and potential maintenance burden. I want a setup that is _closer to the metal_, with a minimum set of components and technologies involved so:

* I understand what I'm doing and how things work
* I can go away from blogging from some time without that knowledge obsoleting
* It is simple to operate and maintain

The main problem I had to solve, and which I am documenting here is that [GitHub pages] runs [Jekyll] in _safe_ mode, which means it is impossible to have plugins. But my posts will have many common patterns that I want to automate, and I want to be [DRY](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself). Hence I need plugins. And then it comes slightly more complicated.

# Principle

The overall principle is to have a single repository with two branches. One that contains the source of the blog, and adequately named `source`. And one that contains the generated site, which must be named `master` for GitHub pages to serve it. It is thus more complicated than just having the source in the `master` branch and letting github generate the site on the fly, a wonderful feature of [GitHub pages] if it were able to support plugins. 

# Creating the source branch

We have to create a new repository with Jekyll boilerplate.  By default, the fist branch of a new git repository is named `master`, which is unfortunate, so we use a bit of git magic to name that branch `source` instead.

{% terminal %}
$ jekyll new xadeck.github.io
New jekyll site installed in /private/tmp/xadeck.github.io.
$ cd xadeck.github.io
$ git init .
Initialized empty Git repository in /private/tmp/xadeck.github.io/.git/
$ git checkout -b source
Switched to a new branch 'source'
$ git add .
$ git commit -m "Initial jekyll scaffold"
[source (root-commit) c3c3638] Initial jekyll scaffold
 16 files changed, 807 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 _config.yml
 ...
 create mode 100644 index.html
 {% endterminal %}

# Creating the master branch

Create the github repository <http://xadeck.github.io> by navigating to your GitHub account and clicking "Create Repository". Then push `source` branch to it.

{% terminal %}
$ git remote add origin https://github.com/Xadeck/xadeck.github.io.git
$ git push -u origin source
{% endterminal %}

At that stage, nothing shows up on <http://xadeck.github.io>, because as mentioned earlier, there is no `master` branch which is the one whose content GitHub serves. Let's create one, with a dummy index page, and push it. We create and orphan branch, and reset it to remove all the files, and then just add the dummy index one.

{% terminal %}
$ git checkout --orphan master
$ git reset --hard 
$ echo 'Coming soon' > index.html
$ git add .
$ git commit -m "Initial GitHub page"
$ git push -u origin master
{% endterminal %}

Now the "Coming soon" page is shown on <http://xadeck.github.io>.

# Setting up workflow

At this stage, we will setup the workflow to edit post in markdown language inside the `source` page, generate the HTML pages (that is Jekyll's job) inside the `master` branch, and push it to GitHub. The key elements here are:

* Use the standard ruby mechanism of `Gemfile` and [bundler] to manage dependencies
* Use git's ability to have a git repository inside another git repository

We will depend on the `github-pages` gem. This gem has two purposes. First it pulls all dependencies needed to use Jekyll. Then it ensures the versions of those dependencies matches the ones in [GitHub pages]. We don't really need that second property, since it's goal is to ensure that pages generated locally will match those generated by [GitHub pages] upon push. But the first property is a simple and stable way to have a running Jekyll locally. So, let's first create a `Gemfile`.

{% terminal %}
$ cat > Gemfile <<END
/source 'https://rubygems.org'
/gem 'github-page'
/END
{% endterminal %}

And perform install with [bundler] (assuming a prior `gem install bundler`). We take care of adding files to the repository, or ignore them appropriately both in `.gitgnore`, so that git status is not polluted by irrelevant by-products, and in `_config.yml` so that Jekyll will not copy them when generating the site.

{% terminal %}
$ bundle install
$ echo Gemfile.lock >> .gitignore
$ echo "exclude: [Gemfile, Gemfile.lock]" >> _config.yml
$ git add Gemfile .gitignore _config.yml
$ git commit -m "Configured Gemfile" 
{% endterminal %}

The next step is the heart of the workflow. We will switch to `source` branch and from now on stay in that branch *but* we will clone the master branch inside a directory named `_site`. That name is reserved by Jekyll is also conveniently already in the `.gitignore` generated by the `jekyll new` command we ran earlier.

{% terminal %}
$ git clone https://github.com/Xadeck/xadeck.github.io.git -b master _site
{% endterminal %}

The effect of that is that when we now run Jekyll, it will generate content in the `_site` directory. This content can be commited in the master branch, and pushed to [GitHub pages], by running the appropriate git commands in the `_site` directory as shown below (read the manual for the various commands, in particular the `-A` option, to understand what happens). 

{% terminal %}
$ jekyll build
$ pushd _site
$ git add -A
$ git commit -m "First generation"
$ git push  # in the _site directory, so pushes to `master` branch
$ popd
{% endterminal %}

Now the generated site shows up at <http://xadeck.githu.io>. We are almost done and the next steps are not stricly necessary, but make things nicer. First, since we generate the site manually, i.e. we locally turn the markdown files to HTML files, we don't need [GitHub pages] to try to do that for us upon pushes to the `master` branch. In practice, when it does so, it finds no markdown files, so it's a no-op. Let's just have the courtesy of letting the bot know about it before hand by adding a `.nojekyll` file.

{% terminal %}
$ pushd _site
$ touch .nojekyll
$ git add .nojekyll
$ git commit -m "Courtesy to GitHub resources"
$ git push 
$ popd
{% endterminal %}

Finally, let's simplify the workflow. Indeed, using pushd/popd to move to the `_site` directory is tedious and error-prone. We should only be working in the root directory, which means in the `source` branch. So let's create a rake task to automate the generation and push of the site. Put the following inside a `Rakefile` file.

{% highlight ruby %}
require "rubygems"

desc "Deploy to Github Pages"
task :deploy do
  puts "## Deploying to Github Pages"

  puts "## Generating site"
  system "jekyll build"

  cd "_site" do
    system "git add -A"

    message = "Site updated at #{Time.now.utc}"
    puts "## Commiting: #{message}"
    system "git commit -m \"#{message}\""

    puts "## Pushing generated site"
    system "git push"

    puts "## Deploy Complete!"
  end
end
{% endhighlight %}
  
Add it to the repository, and also tell Jekyll to ignore it during generation:

{% terminal %}
$ git add Rakefile
$ perl -p -i -e 's(\Qexclude: [Gemfile, Gemfile.lock])(exclude: [Gemfile, Gemfile.lock, Rakefile])' _config.yml
$ git commit -m "Added Rakefile" Rakefile _config.yml
{% endterminal %}

From now on, the workflow is the following one. Run `jekyll serve` locally, work on your posts, commit in the `source` branch as much as you want, push that branch regularly to not loose your edits or to be able to work from different machines using git. Then when you want to update your blog, just run `rake deploy`. _Et voilÃ !_

# Beyond the basics

We finish by addind two useful gems. One is to generate sitemaps automatically. The other one is to easily manages assets such as images and javascripts (Jekyll has builtin support for stylesheets so assets management is not really needed for them, at least in my use case).

{% terminal %}
$ cat >> Gemfile <<END
/gem 'jekyll-sitemaps'
/gem 'jekyll-assets'
/END
$ bundle  
$ cat >> config.yml <<END
/# Enabled plugins
/gems: [jekyll-sitemaps]
/gems: [jekyll-assets]
/END
{% endterminal %}

As an example of using assets, let's add a favicon in `_assets/(images` directory.

{% terminal %}
$ mkdir -p _assets/images
$ wget http://iconhandbook.co.uk/favicon.png _assets/images/
$ git add _assets
{% endterminal %}

Use that in the `_includes/head.html` file, using the handy Liquid tag to get correct path:

{% highlight html %}
{% raw %}
  <link href="{{ 'favicon.png' | asset_path }}" rel="icon">  
{% endraw %}
{% endhighlight %}
    

[Jekyll]:       http://jekyllrb.com/
[GitHub pages]: https://pages.github.com/
[bundler]:      http://bundler.io/